/**
 * meshoptimizer - version 0.20
 *
 * Copyright (C) 2016-2024, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at https://github.com/zeux/meshoptimizer
 *
 * This library is distributed under the MIT License. See notice at the end of this file.
 */
#pragma once

#include <assert.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

 /* Version macro; major * 1000 + minor * 10 + patch */
#define MESHOPTIMIZER_VERSION 200 /* 0.20 */

/* If no API is defined, assume default */
#ifndef MESHOPTIMIZER_API
#define MESHOPTIMIZER_API
#endif

/* Set the calling-convention for alloc/dealloc function pointers */
#ifndef MESHOPTIMIZER_ALLOC_CALLCONV
#ifdef _MSC_VER
#define MESHOPTIMIZER_ALLOC_CALLCONV __cdecl
#else
#define MESHOPTIMIZER_ALLOC_CALLCONV
#endif
#endif

/* Experimental APIs have unstable interface and might have implementation that's not fully tested or optimized */
#define MESHOPTIMIZER_EXPERIMENTAL MESHOPTIMIZER_API

/* C interface */
#ifdef __cplusplus
extern "C" {
#endif

	/**
	 * Vertex attribute stream
	 * Each element takes size bytes, beginning at data, with stride controlling the spacing between successive elements (stride >= size).
	 */
	struct meshopt_Stream
	{
		const void* data;
		size_t size;
		size_t stride;
	};

	/**
 * Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices
 * As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
 * Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.
 *
 * destination must contain enough space for the resulting remap table (vertex_count elements)
 * indices can be NULL if the input is unindexed
 */
	MESHOPTIMIZER_API size_t meshopt_generateVertexRemap(unsigned int* destination, const unsigned int* indices, size_t index_count, const void* vertices, size_t vertex_count, size_t vertex_size);

	/**
	 * Generates a vertex remap table from multiple vertex streams and an optional index buffer and returns number of unique vertices
	 * As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
	 * Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
	 * To remap vertex buffers, you will need to call meshopt_remapVertexBuffer for each vertex stream.
	 * Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.
	 *
	 * destination must contain enough space for the resulting remap table (vertex_count elements)
	 * indices can be NULL if the input is unindexed
	 * stream_count must be <= 16
	 */
	MESHOPTIMIZER_API size_t meshopt_generateVertexRemapMulti(unsigned int* destination, const unsigned int* indices, size_t index_count, size_t vertex_count, const struct meshopt_Stream* streams, size_t stream_count);

	/**
	 * Generates vertex buffer from the source vertex buffer and remap table generated by meshopt_generateVertexRemap
	 *
	 * destination must contain enough space for the resulting vertex buffer (unique_vertex_count elements, returned by meshopt_generateVertexRemap)
	 * vertex_count should be the initial vertex count and not the value returned by meshopt_generateVertexRemap
	 */
	MESHOPTIMIZER_API void meshopt_remapVertexBuffer(void* destination, const void* vertices, size_t vertex_count, size_t vertex_size, const unsigned int* remap);

	/**
	 * Generate index buffer from the source index buffer and remap table generated by meshopt_generateVertexRemap
	 *
	 * destination must contain enough space for the resulting index buffer (index_count elements)
	 * indices can be NULL if the input is unindexed
	 */
	MESHOPTIMIZER_API void meshopt_remapIndexBuffer(unsigned int* destination, const unsigned int* indices, size_t index_count, const unsigned int* remap);

	/**
	 * Simplification options
	 */
	enum
	{
		/* Do not move vertices that are located on the topological border (vertices on triangle edges that don't have a paired triangle). Useful for simplifying portions of the larger mesh. */
		meshopt_SimplifyLockBorder = 1 << 0,
	};

	/**
	 * Mesh simplifier
	 * Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible
	 * The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error.
	 * If not all attributes from the input mesh are required, it's recommended to reindex the mesh using meshopt_generateShadowIndexBuffer prior to simplification.
	 * Returns the number of indices after simplification, with destination containing new index data
	 * The resulting index buffer references vertices from the original vertex buffer.
	 * If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
	 *
	 * destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
	 * options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default
	 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
	 */
	MESHOPTIMIZER_API size_t meshopt_simplify(unsigned int* destination, const unsigned int* indices, size_t index_count, const float* vertex_positions, size_t vertex_count, size_t vertex_positions_stride, size_t target_index_count, float target_error, unsigned int options, float* result_error);

	/**
	 * Experimental: Mesh simplifier with attribute metric
	 * The algorithm ehnahces meshopt_simplify by incorporating attribute values into the error metric used to prioritize simplification order; see meshopt_simplify documentation for details.
	 * Note that the number of attributes affects memory requirements and running time; this algorithm requires ~1.5x more memory and time compared to meshopt_simplify when using 4 scalar attributes.
	 *
	 * vertex_attributes should have attribute_count floats for each vertex
	 * attribute_weights should have attribute_count floats in total; the weights determine relative priority of attributes between each other and wrt position. The recommended weight range is [1e-3..1e-1], assuming attribute data is in [0..1] range.
	 * attribute_count must be <= 16
	 * vertex_lock can be NULL; when it's not NULL, it should have a value for each vertex; 1 denotes vertices that can't be moved
	 * TODO target_error/result_error currently use combined distance+attribute error; this may change in the future
	 */
	MESHOPTIMIZER_EXPERIMENTAL size_t meshopt_simplifyWithAttributes(unsigned int* destination, const unsigned int* indices, size_t index_count, const float* vertex_positions, size_t vertex_count, size_t vertex_positions_stride, const float* vertex_attributes, size_t vertex_attributes_stride, const float* attribute_weights, size_t attribute_count, const unsigned char* vertex_lock, size_t target_index_count, float target_error, unsigned int options, float* result_error);

	/**
	 * Experimental: Mesh simplifier (sloppy)
	 * Reduces the number of triangles in the mesh, sacrificing mesh appearance for simplification performance
	 * The algorithm doesn't preserve mesh topology but can stop short of the target goal based on target error.
	 * Returns the number of indices after simplification, with destination containing new index data
	 * The resulting index buffer references vertices from the original vertex buffer.
	 * If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
	 *
	 * destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 * target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
	 * result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
	 */
	MESHOPTIMIZER_EXPERIMENTAL size_t meshopt_simplifySloppy(unsigned int* destination, const unsigned int* indices, size_t index_count, const float* vertex_positions, size_t vertex_count, size_t vertex_positions_stride, size_t target_index_count, float target_error, float* result_error);

	/**
	 * Experimental: Point cloud simplifier
	 * Reduces the number of points in the cloud to reach the given target
	 * Returns the number of points after simplification, with destination containing new index data
	 * The resulting index buffer references vertices from the original vertex buffer.
	 * If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
	 *
	 * destination must contain enough space for the target index buffer (target_vertex_count elements)
	 * vertex_positions should have float3 position in the first 12 bytes of each vertex
	 * vertex_colors should can be NULL; when it's not NULL, it should have float3 color in the first 12 bytes of each vertex
	 */
	MESHOPTIMIZER_EXPERIMENTAL size_t meshopt_simplifyPoints(unsigned int* destination, const float* vertex_positions, size_t vertex_count, size_t vertex_positions_stride, const float* vertex_colors, size_t vertex_colors_stride, float color_weight, size_t target_vertex_count);

	/**
	 * Returns the error scaling factor used by the simplifier to convert between absolute and relative extents
	 *
	 * Absolute error must be *divided* by the scaling factor before passing it to meshopt_simplify as target_error
	 * Relative error returned by meshopt_simplify via result_error must be *multiplied* by the scaling factor to get absolute error.
	 */
	MESHOPTIMIZER_API float meshopt_simplifyScale(const float* vertex_positions, size_t vertex_count, size_t vertex_positions_stride);

	
#ifdef __cplusplus
} /* extern "C" */
#endif

/* Quantization into commonly supported data formats */
#ifdef __cplusplus
/**
 * Quantize a float in [0..1] range into an N-bit fixed point unorm value
 * Assumes reconstruction function (q / (2^N-1)), which is the case for fixed-function normalized fixed point conversion
 * Maximum reconstruction error: 1/2^(N+1)
 */
inline int meshopt_quantizeUnorm(float v, int N);

/**
 * Quantize a float in [-1..1] range into an N-bit fixed point snorm value
 * Assumes reconstruction function (q / (2^(N-1)-1)), which is the case for fixed-function normalized fixed point conversion (except early OpenGL versions)
 * Maximum reconstruction error: 1/2^N
 */
inline int meshopt_quantizeSnorm(float v, int N);

#endif


/* Inline implementation */
#ifdef __cplusplus
inline int meshopt_quantizeUnorm(float v, int N)
{
	const float scale = float((1 << N) - 1);

	v = (v >= 0) ? v : 0;
	v = (v <= 1) ? v : 1;

	return int(v * scale + 0.5f);
}

inline int meshopt_quantizeSnorm(float v, int N)
{
	const float scale = float((1 << (N - 1)) - 1);

	float round = (v >= 0 ? 0.5f : -0.5f);

	v = (v >= -1) ? v : -1;
	v = (v <= +1) ? v : +1;

	return int(v * scale + round);
}
#endif

/* Internal implementation helpers */
#ifdef __cplusplus
class meshopt_Allocator
{
public:
	template <typename T>
	struct StorageT
	{
		static void* (MESHOPTIMIZER_ALLOC_CALLCONV* allocate)(size_t);
		static void (MESHOPTIMIZER_ALLOC_CALLCONV* deallocate)(void*);
	};

	typedef StorageT<void> Storage;

	meshopt_Allocator()
		: blocks()
		, count(0)
	{
	}

	~meshopt_Allocator()
	{
		for (size_t i = count; i > 0; --i)
			Storage::deallocate(blocks[i - 1]);
	}

	template <typename T> T* allocate(size_t size)
	{
		assert(count < sizeof(blocks) / sizeof(blocks[0]));
		T* result = static_cast<T*>(Storage::allocate(size > size_t(-1) / sizeof(T) ? size_t(-1) : size * sizeof(T)));
		blocks[count++] = result;
		return result;
	}

	void deallocate(void* ptr)
	{
		assert(count > 0 && blocks[count - 1] == ptr);
		Storage::deallocate(ptr);
		count--;
	}

private:
	void* blocks[24];
	size_t count;
};

// This makes sure that allocate/deallocate are lazily generated in translation units that need them and are deduplicated by the linker
template <typename T> void* (MESHOPTIMIZER_ALLOC_CALLCONV* meshopt_Allocator::StorageT<T>::allocate)(size_t) = operator new;
template <typename T> void (MESHOPTIMIZER_ALLOC_CALLCONV* meshopt_Allocator::StorageT<T>::deallocate)(void*) = operator delete;
#endif



/**
 * Copyright (c) 2016-2024 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */